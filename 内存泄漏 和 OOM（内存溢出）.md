内存泄漏 和 OOM（内存溢出）
---
> 大量的内存泄漏就会导致内存溢出；

### 内存泄漏：
> 如何判断对象无引用：
> 引用计数法：给对象设定一个计数器，每被引用一次就计数，Python 采用这种方法；但是两个无用的对象互相引用就会导致计数器不为0 回收不了；
>  
>  可达性分析：通过设定的 “GC Roots” 对象为索引的起点，如果一个对象与起点对象的之间均无可达路径（有点像图）；那就判定这个不可达的对象就会成为回收对象

GC回收不了的逻辑上的无用对象一直堆积在内存中，直到程序结束，就是所谓的内存泄漏；当内存泄漏累积到一定程度，内存被消耗完，就会导致卡顿，崩溃的现象，即OOM；

内存泄漏分析工具：
AS 的 Android Monitor中的 Monitors
eclipse 的 MAT


#### 会导致内存泄漏的情况：
+ 集合类泄漏 （Hashmap 只存不删）
+ 单例 / 静态变量造成的内存泄漏
+ 匿名内部类 / 非静态内部类（handle,Asynctask）
+ 资源未关闭造成的内存泄漏


###  OOM 内存溢出
APP 向系统申请超过最大阀值的内存请求，系统无法分配多余空间，就会出现OOM；

导致情况：
+ 图片过大不当处理加载；
+ 相应的资源过多，来不及释放；

每个App由于手机厂商的不同，会导致不同手机给分配的 内存空间不同；
可以手动查询;
Runtime.getRuntime()。通过maxMemory()方法获取系统可为APP分配的最大内存，totalMemory() 获取APP当前所分配的内存heap空间大小。

西邮Grade 三星s7e
最大 ： 268M         APP:  50M

ChinaRallWay  
最大 ： 268M          APP：28M

### 优化策略：
1. 优化 static 修饰块的使用，一般用来修饰基本数据类型或者轻量级对象，避免修饰集合 或者大对象；

2. 减少无关引用；
3. 多使用 软引用，弱引用，或者 LruCache作为引用的存放；
4. Bitmap 的压缩处理；
5. Cursor 及时关闭，可以把承载的内容给回收掉；
6. 页面背景 和 图片加载，减少资源的大小；
例如：纯色背景用 color ；规则图形则用 shape 画图；复杂页面采用 针对机型 的切图选择；
7. 利用第三方框架带缓存机制的进行图片加载；
8. 广播和服务不用的时候，需要解绑
9. I/O操作结束后关闭；
10. 线程不用的时候，需要关闭；根据CPU的调度能力，控制线程数，线程数较多的情况下，使用线程池进行优化；
11. Stringbuffer 代替 string；
12. 还有最直接的方法，自定义堆大小；
